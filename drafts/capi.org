#+TITLE: Better support for C extensions in TruffleRuby.
#+DATE: 2018-12-31 Mon
We've been able to support C extensions in TruffleRuby for a long time
now, but we've always had to patch them while building the C for them
to work. We've just added much better support which almost completely
removes the need to patch extensions. In this article I'll explain how
Truffle based languages can support polyglot calls, how C extensions
used to work in TruffleRuby, how they now work, and what the remaining
differences are with MRI.
* Interactions between Truffle languages
All Truffle languages can provide support for other languages to
access data and make calls by defining how foreign access is
resolved. This covers things like asking if an object is executable,
or has a size, reading and writing public accessible fields, and so
forth. So JavaScript can easily call methods on a Ruby object, or
access members of a Ruby array as long we we provide foreign access
for Ruby objects.

There is also support for lower level concepts in the foreign access
APIs.  You can convert an object to a native representation, as well
as checking whether that object can behave like a pointer.

These facilities don't cover everything though, so Sulong provides a
set of functions for converting almsot any object into a native handle
and back again. I say almost any object because boxed primitives such
as ~java.lang.Integer~ are not supported, but you can always arrange
to wrap these to avoid the problem.
* C extensions the old way
We used Truffle's polyglot features to call C functions from Ruby, and
Ruby methods from C, without touching the arguments at all. This
allowed Ruby objects to pass easily through C code that is interpreted
by Sulong, but fails if those objects have to be passed to a native
shared library or stored on the native heap. To solve that problem we
would patch C extensions in too ways.
** Managed memory
The first way to avoid problems with the translation of Ruby objects to
native pointers is to avoid doing as much as possible. By default we'd
replace every array of ~VALUE~ objects (which would be stored on the
native heap) with a managed object that could store the object without
conversion. We could also allocate managed structs instead of native
one, but this became complicated with complex structures which had
nested members of fused arrays.
** Handles everywhere
The second way to solve these problems was to use the functions Sulong
provided to convert between managed objects and native handles. These
functions were hard to use without introducing memory leaks however,
and did require that we patched every point at which a Ruby object
needed to be converted to or from native memory.
* Difficult issues with our old approach
So, there are a couple of issues with the old approach and resource
leaks. Let's take a look at the behaviour we would like, the problems
we could see with the old approach, and how we what we could do to fix
those. We'll start by considering a simple case of three objects A, B,
and C. A will be a GC root (i.e. it's either some sort of global
object or a variable which the garbage collector knows cannot be
removed), and B and C are Ruby objects. A will have an instance
variable of B, and B will have one of C. So A has a hard reference to
B and B has a hard reference to C like this.
#+BEGIN_SRC dot :file diagram.svg :exports results
digraph D {

 A [shape = box color = red]
 B [shape = box]
 C [shape = box]

 A -> B [color=red]
 B -> C [color=red]
}
#+END_SRC

#+RESULTS:
[[file:diagram.svg]]

We'll use red arrows to indicate hard references from now on,m and red
boxes to indicate GC roots. The good thing here is that if A stops
being a root, or a hard reference is removed then some or all of the
objects can be collected.

Now, what happens when A, B, and C are C structs which have been
wrapped in Ruby objects? Well, now our hard references are jst
~VALUEs~ in the structs, and for the GC to know those are alive each
object must mark those it has references to. We'll use purple to mark
marked links.

#+BEGIN_SRC dot :file diagram2.svg :exports results
digraph D {

 A [shape = box color = red]
 B [shape = box]
 C [shape = box]

 A -> B [color=purple]
 B -> C [color=purple]
}
#+END_SRC

#+RESULTS:
[[file:diagram2.svg]]

So in this situation if A stops marking B, or B stops marking C then
those objects can be collected.

Now what happens in TruffleRuby when we use handles?

#+BEGIN_SRC dot :file diagram3.svg :exports results
digraph D {

 X [label="Handle table" shape=box color = red]
 A [shape = box color = red]
 B [shape = box]
 C [shape = box]

 A -> B [color=blue]
 B -> C [color=blue]

 X -> B [color=red]
 X -> C [color=red]
}
#+END_SRC

#+RESULTS:
[[file:diagram3.svg]]

Now we have a problem. The references from A to B, and B to C are weak
(they are simple handle numbers) so the handle table has to associate
those with the objects they represent by keeping a strong
reference. For C to be garbage collected we would need to remove the
handle pointing to it. Easy right? Well, not always. Let us consider a
tree like this

#+BEGIN_SRC dot :file diagram4.svg :exports results
digraph D {

 Object [shape = box color = red]

 Document [shape = box]
 NodeA [shape = box]
 NodeB [shape = box]
 NodeC [shape = box]
 NodeD [shape = box]

 Object -> Document [color=red]
 Document -> NodeA [color=red]
 NodeA -> NodeB [color=red]
 NodeA -> NodeC [color=red]
 Document -> NodeD [color=red]

 NodeA -> Document [color=red]
 NodeB -> Document [color=red]
 NodeC -> Document [color=red]
 NodeD -> Document [color=red]
}
#+END_SRC

#+RESULTS:
[[file:diagram4.svg]]

This is a common sort of structure to find in tools like XML
processors. Each node has a reference to the parent document, and to
its own children. If we break the hard reference from the GC root
object to the document then it and all of its nodes can be
collected. The same is true if the nodes hold ~VALUEs~ and mark them,
but what happens if we use handles?

#+BEGIN_SRC dot :file diagram5.svg :exports results
digraph D {

 Object [shape = box color = red]
 X [label="Handle table" shape=box color = red]

 Document [shape = box]
 NodeA [shape = box]
 NodeB [shape = box]
 NodeC [shape = box]
 NodeD [shape = box]

 Object -> Document  [color=blue]
 Document -> NodeA [color=blue]
 NodeA -> NodeB [color=blue]
 NodeA -> NodeC [color=blue]
 Document -> NodeD [color=blue]

 NodeA -> Document [color=blue]
 NodeB -> Document [color=blue]
 NodeC -> Document [color=blue]
 NodeD -> Document [color=blue]

 X -> Document [color=red]
 X -> NodeA [color=red]
 X -> NodeB [color=red]
 X -> NodeC [color=red]
 X -> NodeD [color=red]
}
#+END_SRC

#+RESULTS:
[[file:diagram5.svg]]

Well, our diagram has certainly got messier! But it's also hard to
know how we should free those handles nicely. There doesn't seem to be
a nice obvious order in which we coiuld do it, and breaking the hard
reference from Object to Document won't be enough to free the
document. We could untangle this if some of those refrences were weak.
* C extensions the new way
Our previous approach was enough to get several key C extensions
working, but sometimes they required large patches, and avoiding
resource leaks was tricky. We prototyped several approaches, either
making as many parts as possible managed objects to avoid conversion,
or allowing all Ruby objects to be converted to native pointers, but
both these approaches had issues. So we tried a third approach,
wrapping every Ruby object.
** Wrapping and unwrapping
The idea is fairly simple. C extensions will never see raw Ruby
object, they will only ever see wrappers that know how to convert
themselves to native pointers, and at every point where a Ruby object
needs to be extracted from a wrapper we know there should only ever be
a wrapper or a native pointer. This makes it easy to convert back from
a native pointer to a wrapper. Best of all C extensions don't have to
know this is happening, so although it required a lot of changes to
our C code to wrap and unwrap values that is as far as the changes go.
** Tidying up wrappers
It was also important that these wrappers didn't cause the objects
they wrapped to live longer than expected. This was a real problem
with the handle conversion we used to do, and we didn't want to make
it worse. Wrappers obviously need to keep a strong reference to the
object they wrap, and objects should also keep a strong reference to
their wrapper, but converting an object to a native pointer should not
stop it from getting garbage collected at some point, but equally it
mustn't be collected too soon.
** Keeping objects alive in MRI
MRI keeps objects alive in two ways when they are being used in a C
extension.Any object still on the stack will be seen by the GC and
kept alive, but that isn't enough to preserve values which may have
been assigned to to a field in a structure. MRI allows these to be
kept alive by associating the structure with a Ruby object, and
allowing that object to mark other it has references to. So, when the
garbage collector traverses all the objects in your Ruby heap it calls
these custom mark functions and the objects will be marked as live as
long as the owners are. There's just one problem, we don't have a GC
which can call custom mark functions, we have to work with any GC on
the JVM. We also can't change the GC to look for native pointers on
the stack which should also keep their respective objects alive.
** Periodic marking
We can solve this by keeping two lists of objects that need to be kept
alive. Then each time we convert a wrapper to a native pointer we will
add the wrapper to the lists, and it will in turn keep its object
alive. One list is for those objects with pointers on the stack. We
can create this list whenever we enter a C extension, and destroy it
again when we finish the call. The other list is a fixed size buffer
of every wrapper converted to a pointer. Whenever this list becomes
full we'll run any marking functions associated with live objects and
attach a lists of marked objects to their owners.
* Improved compatibility and remaining differences
Applying these changes has allowed us to remove almost all our patches
for C extensions, even for complex ones such as zlib, OpenSSl, or pg,
but that doesn't mean we're completely finished. Translating between
Ruby objects and native pointers requires updating a global hash
table, which is relatively expensive. We can reduce that by tagging
the pointers for common types, so true, false, nil, and so forth
always convert to the same native value and never need to touch the
hash table. Likewise fixnums can be tagged to cover most of their
range, and we can probably use a similar technique for doubles or
interned symbols.

There are however still some fundamental differences between us and
MRI, but they are much smaller than they were. One is that our ~VALUE~
type is a ~void *~ in C. This means we can't do a switch on a
~VALUE~. We will experiment with using ~long~ for ~VALUE~, but this
may require some changes to Sulong for support.

We also can't yet translate a pointer to a Ruby array's contents to
native. This requires storing the contents in native memory so that
they can be read and altered from C, but ensuring that the view of the
array from Ruby remains consistent with these changes. It's
technically perfectly possible but will require some work on our array
code to support it.

There are also some small differences imposed by our use of Sulong to
interpret C extensions. One is function declarations may need to be
changed. For example a function declared as taking two arguments must
be passed two arguments, even if the second one is never used, and
~int~ and pointer types may not be as interchangeable as they can be
in native C. We also have trouble with varargs functions in managed
code being called from native libraries, but none of these differences
causes widespread problems and most can be patched without change the
behaviour of any C extensions.
